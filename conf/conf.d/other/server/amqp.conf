server {
  listen 15673;

  server_name amqp;

  location ~* ^/publish/([^/]+) {
    set $exchange $1;
    content_by_lua_block {
      local amqp = require "ngx_amqp"
      local ok, err = amqp.publish( { name        = ngx.var.exchange,
                                      routing_key = ngx.var.arg_routing_key or "" }, ngx.var.arg_msg )
      if ok then
        ngx.say("Published")
      else
        ngx.say(err)
      end
    }
  }

  location ~* ^/exchange_declare/([^/]+) {
    set $exchange $1;
    content_by_lua_block {
      local amqp = require "ngx_amqp"
      local toboolean = function(v) if v and v:match("^[1Yy]$") then return true else return false end end
      local ok, err = amqp.exchange_declare( { name        = ngx.var.exchange,
                                               typ         = ngx.var.arg_typ or "topic",
                                               durable     = toboolean(ngx.var.arg_durable     or "1"),
                                               auto_delete = toboolean(ngx.var.arg_auto_delete or "0"),
                                               passive     = toboolean(ngx.var.arg_passive     or "0"),
                                               internal    = toboolean(ngx.var.arg_internal    or "0"),
                                               no_wait     = toboolean(ngx.var.arg_no_wait     or "0")} )
      if ok then
        ngx.say("Declared")
      else
        ngx.say(err)
      end
    }
  }
  
  location ~* ^/queue_declare/([^/]+) {
    set $queue $1;
    content_by_lua_block {
      local amqp = require "ngx_amqp"
      local toboolean = function(v) if v and v:match("^[1Yy]$") then return true else return false end end
      local ok, err = amqp.queue_declare( { name        = ngx.var.queue,
                                            durable     = toboolean(ngx.var.arg_durable     or "1"),
                                            auto_delete = toboolean(ngx.var.arg_auto_delete or "0"),
                                            passive     = toboolean(ngx.var.arg_passive     or "0"),
                                            no_wait     = toboolean(ngx.var.arg_no_wait     or "0")} )
      if ok then
        ngx.say("Declared")
      else
        ngx.say(err)
      end
    }
  }

  location ~* ^/queue_bind/([^/]+) {
    set $queue $1;
    content_by_lua_block {
      local amqp = require "ngx_amqp"
      local toboolean = function(v) if v and v:match("^[1Yy]$") then return true else return false end end
      local ok, err = amqp.queue_bind( { queue       = ngx.var.queue,
                                         exchange    = ngx.var.arg_exchange,
                                         routing_key = ngx.var.arg_routing_key,
                                         no_wait     = toboolean(ngx.var.arg_no_wait or "0")} )
      if ok then
        ngx.say("Bound")
      else
        ngx.say(err)
      end
    }
  }

  location ~* ^/queue_unbind/([^/]+) {
    set $queue $1;
    content_by_lua_block {
      local amqp = require "ngx_amqp"
      local toboolean = function(v) if v and v:match("^[1Yy]$") then return true else return false end end
      local ok, err = amqp.queue_unbind( { queue       = ngx.var.queue,
                                           exchange    = ngx.var.arg_exchange,
                                           routing_key = ngx.var.arg_routing_key } )
      if ok then
        ngx.say("Unbound")
      else
        ngx.say(err)
      end
    }
  }

  location ~* ^/exchange_bind {
    content_by_lua_block {
      local amqp = require "ngx_amqp"
      local toboolean = function(v) if v and v:match("^[1Yy]$") then return true else return false end end
      local ok, err = amqp.exchange_bind( { destination = ngx.var.arg_destination,
                                            source      = ngx.var.arg_source,
                                            routing_key = ngx.var.arg_routing_key,
                                            no_wait     = toboolean(ngx.var.arg_no_wait or "0")} )
      if ok then
        ngx.say("Bound")
      else
        ngx.say(err)
      end
    }
  }

  location ~* ^/exchange_unbind {
    content_by_lua_block {
      local amqp = require "ngx_amqp"
      local toboolean = function(v) if v and v:match("^[1Yy]$") then return true else return false end end
      local ok, err = amqp.exchange_unbind( { destination = ngx.var.arg_destination,
                                              source      = ngx.var.arg_source,
                                              routing_key = ngx.var.arg_routing_key,
                                              no_wait     = toboolean(ngx.var.arg_no_wait or "0")} )
      if ok then
        ngx.say("Unbound")
      else
        ngx.say(err)
      end
    }
  }

  location ~* ^/exchange_delete/([^/]+) {
    set $exchange $1;
    content_by_lua_block {
      local amqp = require "ngx_amqp"
      local toboolean = function(v) if v and v:match("^[1Yy]$") then return true else return false end end
      local ok, err = amqp.exchange_delete( { exchange    = ngx.var.exchange,
                                              if_unused   = toboolean(ngx.var.arg_if_unused or "1"),
                                              no_wait     = toboolean(ngx.var.arg_no_wait or "0") } )
      if ok then
        ngx.say("Deleted")
      else
        ngx.say(err)
      end
    }
  }

  location ~* ^/queue_delete/([^/]+) {
    set $queue $1;
    content_by_lua_block {
      local amqp = require "ngx_amqp"
      local toboolean = function(v) if v and v:match("^[1Yy]$") then return true else return false end end
      local ok, err = amqp.queue_delete( { queue       = ngx.var.queue,
                                           if_unused   = toboolean(ngx.var.arg_if_unused or "1"),
                                           if_empty    = toboolean(ngx.var.arg_if_empty or "1"),
                                           no_wait     = toboolean(ngx.var.arg_no_wait or "0") } )
      if ok then
        ngx.say("Deleted")
      else
        ngx.say(err)
      end
    }
  }
  
  location = /info {
    default_type application/json;
    content_by_lua_block {
      local cjson = require "cjson"
      local amqp = require "ngx_amqp"
      ngx.say(cjson.encode(amqp.info()))
    }
  }
}